commit d99486bda5601cb887ac898037a2dfad795aeb8f
Author: Maarten Lankhorst <m.b.lankhorst@gmail.com>
Date:   Wed May 23 09:29:29 2012 +0200

    awful hack to remove dependency on libdrm_nouveau

diff --git a/configure.ac b/configure.ac
index afb6cde..7326144 100644
--- a/configure.ac
+++ b/configure.ac
@@ -67,7 +67,8 @@ XORG_DRIVER_CHECK_EXT(XV, videoproto)
 XORG_DRIVER_CHECK_EXT(DPMSExtension, xextproto)
 
 # Checks for pkg-config packages
-PKG_CHECK_MODULES(LIBDRM_NOUVEAU, [libdrm_nouveau >= 2.4.25])
+PKG_CHECK_MODULES(LIBDRM_NOUVEAU_DUMMY, [libdrm_nouveau = 0.6])
+PKG_CHECK_MODULES(LIBDRM_NOUVEAU, [libdrm])
 AC_SUBST(LIBDRM_NOUVEAU_CFLAGS)
 AC_SUBST(LIBDRM_NOUVEAU_LIBS)
 
diff --git a/drm_nouveau/abi16.c b/drm_nouveau/abi16.c
new file mode 100644
index 0000000..69a0a9b
--- /dev/null
+++ b/drm_nouveau/abi16.c
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#include "private.h"
+
+int
+abi16_chan_nv04(struct nouveau_object *obj)
+{
+	struct nouveau_device *dev = (struct nouveau_device *)obj->parent;
+	struct drm_nouveau_channel_alloc req;
+	struct nv04_fifo *nv04 = obj->data;
+	int ret;
+
+	req.fb_ctxdma_handle = nv04->vram;
+	req.tt_ctxdma_handle = nv04->gart;
+
+	ret = drmCommandWriteRead(dev->fd, DRM_NOUVEAU_CHANNEL_ALLOC,
+				  &req, sizeof(req));
+	if (ret)
+		return ret;
+
+	nv04->base.channel = req.channel;
+	nv04->base.pushbuf = req.pushbuf_domains;
+	nv04->notify = req.notifier_handle;
+	nv04->base.object->handle = req.channel;
+	nv04->base.object->length = sizeof(*nv04);
+	return 0;
+}
+
+int
+abi16_chan_nvc0(struct nouveau_object *obj)
+{
+	struct nouveau_device *dev = (struct nouveau_device *)obj->parent;
+	struct drm_nouveau_channel_alloc req = {};
+	struct nvc0_fifo *nvc0 = obj->data;
+	int ret;
+
+	ret = drmCommandWriteRead(dev->fd, DRM_NOUVEAU_CHANNEL_ALLOC,
+				  &req, sizeof(req));
+	if (ret)
+		return ret;
+
+	nvc0->base.channel = req.channel;
+	nvc0->base.pushbuf = req.pushbuf_domains;
+	nvc0->notify = req.notifier_handle;
+	nvc0->base.object->handle = req.channel;
+	nvc0->base.object->length = sizeof(*nvc0);
+	return 0;
+}
+
+int
+abi16_engobj(struct nouveau_object *obj)
+{
+	struct drm_nouveau_grobj_alloc req = {
+		obj->parent->handle, obj->handle, obj->oclass
+	};
+	struct nouveau_device *dev;
+	int ret;
+
+	dev = nouveau_object_find(obj, NOUVEAU_DEVICE_CLASS);
+	ret = drmCommandWrite(dev->fd, DRM_NOUVEAU_GROBJ_ALLOC,
+			      &req, sizeof(req));
+	if (ret)
+		return ret;
+
+	obj->length = sizeof(struct nouveau_object *);
+	return 0;
+}
+
+int
+abi16_ntfy(struct nouveau_object *obj)
+{
+	struct nv04_notify *ntfy = obj->data;
+	struct drm_nouveau_notifierobj_alloc req = {
+		obj->parent->handle, ntfy->object->handle, ntfy->length
+	};
+	struct nouveau_device *dev;
+	int ret;
+
+	dev = nouveau_object_find(obj, NOUVEAU_DEVICE_CLASS);
+	ret = drmCommandWriteRead(dev->fd, DRM_NOUVEAU_NOTIFIEROBJ_ALLOC,
+				  &req, sizeof(req));
+	if (ret)
+		return ret;
+
+	ntfy->offset = req.offset;
+	ntfy->object->length = sizeof(*ntfy);
+	return 0;
+}
+
+void
+abi16_bo_info(struct nouveau_bo *bo, struct drm_nouveau_gem_info *info)
+{
+	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
+
+	nvbo->map_handle = info->map_handle;
+	bo->handle = info->handle;
+	bo->size = info->size;
+	bo->offset = info->offset;
+
+	bo->flags = 0;
+	if (info->domain & NOUVEAU_GEM_DOMAIN_VRAM)
+		bo->flags |= NOUVEAU_BO_VRAM;
+	if (info->domain & NOUVEAU_GEM_DOMAIN_GART)
+		bo->flags |= NOUVEAU_BO_GART;
+	if (!(info->tile_flags & NOUVEAU_GEM_TILE_NONCONTIG))
+		bo->flags |= NOUVEAU_BO_CONTIG;
+	if (nvbo->map_handle)
+		bo->flags |= NOUVEAU_BO_MAP;
+
+	if (bo->device->chipset >= 0xc0) {
+		bo->config.nvc0.memtype   = (info->tile_flags & 0xff00) >> 8;
+		bo->config.nvc0.tile_mode = info->tile_mode;
+	} else
+	if (bo->device->chipset >= 0x80 || bo->device->chipset == 0x50) {
+		bo->config.nv50.memtype   = (info->tile_flags & 0x07f00) >> 8 |
+					    (info->tile_flags & 0x30000) >> 9;
+		bo->config.nv50.tile_mode = info->tile_mode << 4;
+	} else {
+		bo->config.nv04.surf_flags = info->tile_flags & 7;
+		bo->config.nv04.surf_pitch = info->tile_mode;
+	}
+}
+
+int
+abi16_bo_init(struct nouveau_bo *bo, uint32_t alignment,
+	      union nouveau_bo_config *config)
+{
+	struct nouveau_device *dev = bo->device;
+	struct drm_nouveau_gem_new req = {};
+	struct drm_nouveau_gem_info *info = &req.info;
+	int ret;
+
+	if (bo->flags & NOUVEAU_BO_VRAM)
+		info->domain |= NOUVEAU_GEM_DOMAIN_VRAM;
+	if (bo->flags & NOUVEAU_BO_GART)
+		info->domain |= NOUVEAU_GEM_DOMAIN_GART;
+	if (!info->domain)
+		info->domain |= NOUVEAU_GEM_DOMAIN_VRAM |
+				NOUVEAU_GEM_DOMAIN_GART;
+
+	if (bo->flags & NOUVEAU_BO_MAP)
+		info->domain |= NOUVEAU_GEM_DOMAIN_MAPPABLE;
+
+	if (!(bo->flags & NOUVEAU_BO_CONTIG))
+		info->tile_flags = NOUVEAU_GEM_TILE_NONCONTIG;
+
+	info->size = bo->size;
+	req.align = alignment;
+
+	if (config) {
+		if (dev->chipset >= 0xc0) {
+			info->tile_flags = (config->nvc0.memtype & 0xff) << 8;
+			info->tile_mode  = config->nvc0.tile_mode;
+		} else
+		if (dev->chipset >= 0x80 || dev->chipset == 0x50) {
+			info->tile_flags = (config->nv50.memtype & 0x07f) << 8 |
+					   (config->nv50.memtype & 0x180) << 9;
+			info->tile_mode  = config->nv50.tile_mode >> 4;
+		} else {
+			info->tile_flags = config->nv04.surf_flags & 7;
+			info->tile_mode  = config->nv04.surf_pitch;
+		}
+	}
+
+	if (!nouveau_device(dev)->have_bo_usage)
+		info->tile_flags &= 0x0000ff00;
+
+	ret = drmCommandWriteRead(dev->fd, DRM_NOUVEAU_GEM_NEW,
+				  &req, sizeof(req));
+	if (ret == 0)
+		abi16_bo_info(bo, &req.info);
+	return ret;
+}
diff --git a/drm_nouveau/bufctx.c b/drm_nouveau/bufctx.c
new file mode 100644
index 0000000..23d6f09
--- /dev/null
+++ b/drm_nouveau/bufctx.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <assert.h>
+#include <errno.h>
+
+#include "libdrm_lists.h"
+
+#include "nouveau.h"
+#include "private.h"
+
+struct nouveau_bufref_priv {
+	struct nouveau_bufref base;
+	struct nouveau_bufref_priv *next;
+	struct nouveau_bufctx *bufctx;
+};
+
+static inline struct nouveau_bufref_priv *
+nouveau_bufref(struct nouveau_bufref *bctx)
+{
+	return (struct nouveau_bufref_priv *)bctx;
+}
+
+struct nouveau_bufbin_priv {
+	struct nouveau_bufref_priv *list;
+	int relocs;
+};
+
+struct nouveau_bufctx_priv {
+	struct nouveau_bufctx base;
+	struct nouveau_bufref_priv *free;
+	int nr_bins;
+	struct nouveau_bufbin_priv bins[];
+};
+
+static inline struct nouveau_bufctx_priv *
+nouveau_bufctx(struct nouveau_bufctx *bctx)
+{
+	return (struct nouveau_bufctx_priv *)bctx;
+}
+
+int
+nouveau_bufctx_new(struct nouveau_client *client, int bins,
+		   struct nouveau_bufctx **pbctx)
+{
+	struct nouveau_bufctx_priv *priv;
+
+	priv = calloc(1, sizeof(*priv) + sizeof(priv->bins[0]) * bins);
+	if (priv) {
+		DRMINITLISTHEAD(&priv->base.head);
+		DRMINITLISTHEAD(&priv->base.pending);
+		DRMINITLISTHEAD(&priv->base.current);
+		priv->base.client = client;
+		priv->nr_bins = bins;
+		*pbctx = &priv->base;
+		return 0;
+	}
+
+	return -ENOMEM;
+}
+
+void
+nouveau_bufctx_del(struct nouveau_bufctx **pbctx)
+{
+	struct nouveau_bufctx_priv *pctx = nouveau_bufctx(*pbctx);
+	struct nouveau_bufref_priv *pref;
+	if (pctx) {
+		while (pctx->nr_bins--)
+			nouveau_bufctx_reset(&pctx->base, pctx->nr_bins);
+		while ((pref = pctx->free)) {
+			pctx->free = pref->next;
+			free(pref);
+		}
+		free(pctx);
+		*pbctx = NULL;
+	}
+}
+
+void
+nouveau_bufctx_reset(struct nouveau_bufctx *bctx, int bin)
+{
+	struct nouveau_bufctx_priv *pctx = nouveau_bufctx(bctx);
+	struct nouveau_bufbin_priv *pbin = &pctx->bins[bin];
+	struct nouveau_bufref_priv *pref;
+
+	while ((pref = pbin->list)) {
+		DRMLISTDELINIT(&pref->base.thead);
+		pbin->list = pref->next;
+		pref->next = pctx->free;
+		pctx->free = pref;
+	}
+
+	bctx->relocs -= pbin->relocs;
+	pbin->relocs  = 0;
+}
+
+struct nouveau_bufref *
+nouveau_bufctx_refn(struct nouveau_bufctx *bctx, int bin,
+		    struct nouveau_bo *bo, uint32_t flags)
+{
+	struct nouveau_bufctx_priv *pctx = nouveau_bufctx(bctx);
+	struct nouveau_bufbin_priv *pbin = &pctx->bins[bin];
+	struct nouveau_bufref_priv *pref = pctx->free;
+
+	if (!pref)
+		pref = malloc(sizeof(*pref));
+	else
+		pctx->free = pref->next;
+
+	if (pref) {
+		pref->base.bo = bo;
+		pref->base.flags = flags;
+		pref->base.packet = 0;
+
+		DRMLISTADDTAIL(&pref->base.thead, &bctx->pending);
+		pref->bufctx = bctx;
+		pref->next = pbin->list;
+		pbin->list = pref;
+	}
+
+	return &pref->base;
+}
+
+struct nouveau_bufref *
+nouveau_bufctx_mthd(struct nouveau_bufctx *bctx, int bin, uint32_t packet,
+		    struct nouveau_bo *bo, uint64_t data, uint32_t flags,
+		    uint32_t vor, uint32_t tor)
+{
+	struct nouveau_bufctx_priv *pctx = nouveau_bufctx(bctx);
+	struct nouveau_bufbin_priv *pbin = &pctx->bins[bin];
+	struct nouveau_bufref *bref = nouveau_bufctx_refn(bctx, bin, bo, flags);
+	if (bref) {
+		bref->packet = packet;
+		bref->data = data;
+		bref->vor = vor;
+		bref->tor = tor;
+		pbin->relocs++;
+		bctx->relocs++;
+	}
+	return bref;
+}
diff --git a/drm_nouveau/libdrm_lists.h b/drm_nouveau/libdrm_lists.h
new file mode 100644
index 0000000..8926d8d
--- /dev/null
+++ b/drm_nouveau/libdrm_lists.h
@@ -0,0 +1,118 @@
+/**************************************************************************
+ *
+ * Copyright 2006 Tungsten Graphics, Inc., Bismarck, ND. USA.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ */
+
+/*
+ * List macros heavily inspired by the Linux kernel
+ * list handling. No list looping yet.
+ */
+
+#include <stddef.h>
+
+typedef struct _drmMMListHead
+{
+    struct _drmMMListHead *prev;
+    struct _drmMMListHead *next;
+} drmMMListHead;
+
+#define DRMINITLISTHEAD(__item)		       \
+  do{					       \
+    (__item)->prev = (__item);		       \
+    (__item)->next = (__item);		       \
+  } while (0)
+
+#define DRMLISTADD(__item, __list)		\
+  do {						\
+    (__item)->prev = (__list);			\
+    (__item)->next = (__list)->next;		\
+    (__list)->next->prev = (__item);		\
+    (__list)->next = (__item);			\
+  } while (0)
+
+#define DRMLISTADDTAIL(__item, __list)		\
+  do {						\
+    (__item)->next = (__list);			\
+    (__item)->prev = (__list)->prev;		\
+    (__list)->prev->next = (__item);		\
+    (__list)->prev = (__item);			\
+  } while(0)
+
+#define DRMLISTDEL(__item)			\
+  do {						\
+    (__item)->prev->next = (__item)->next;	\
+    (__item)->next->prev = (__item)->prev;	\
+  } while(0)
+
+#define DRMLISTDELINIT(__item)			\
+  do {						\
+    (__item)->prev->next = (__item)->next;	\
+    (__item)->next->prev = (__item)->prev;	\
+    (__item)->next = (__item);			\
+    (__item)->prev = (__item);			\
+  } while(0)
+
+#define DRMLISTENTRY(__type, __item, __field)   \
+    ((__type *)(((char *) (__item)) - offsetof(__type, __field)))
+
+#define DRMLISTEMPTY(__item) ((__item)->next == (__item))
+
+#define DRMLISTSINGLE(__list) \
+	(!DRMLISTEMPTY(__list) && ((__list)->next == (__list)->prev))
+
+#define DRMLISTFOREACH(__item, __list)					\
+	for ((__item) = (__list)->next;					\
+	     (__item) != (__list); (__item) = (__item)->next)
+
+#define DRMLISTFOREACHSAFE(__item, __temp, __list)			\
+	for ((__item) = (__list)->next, (__temp) = (__item)->next;	\
+	     (__item) != (__list);					\
+	     (__item) = (__temp), (__temp) = (__item)->next)
+
+#define DRMLISTFOREACHSAFEREVERSE(__item, __temp, __list)		\
+	for ((__item) = (__list)->prev, (__temp) = (__item)->prev;	\
+	     (__item) != (__list);					\
+	     (__item) = (__temp), (__temp) = (__item)->prev)
+
+#define DRMLISTFOREACHENTRY(__item, __list, __head)                            \
+	for ((__item) = DRMLISTENTRY(typeof(*__item), (__list)->next, __head); \
+	     &(__item)->__head != (__list);                                    \
+	     (__item) = DRMLISTENTRY(typeof(*__item),                          \
+				     (__item)->__head.next, __head))
+
+#define DRMLISTFOREACHENTRYSAFE(__item, __temp, __list, __head)                \
+	for ((__item) = DRMLISTENTRY(typeof(*__item), (__list)->next, __head), \
+	     (__temp) = DRMLISTENTRY(typeof(*__item),                          \
+				     (__item)->__head.next, __head);           \
+	     &(__item)->__head != (__list);                                    \
+	     (__item) = (__temp),                                              \
+	     (__temp) = DRMLISTENTRY(typeof(*__item),                          \
+				     (__temp)->__head.next, __head))
+
+#define DRMLISTJOIN(__list, __join) if (!DRMLISTEMPTY(__list)) {	\
+	(__list)->next->prev = (__join);				\
+	(__list)->prev->next = (__join)->next;				\
+	(__join)->next->prev = (__list)->prev;				\
+	(__join)->next = (__list)->next;				\
+}
diff --git a/drm_nouveau/nouveau.c b/drm_nouveau/nouveau.c
new file mode 100644
index 0000000..5aa4107
--- /dev/null
+++ b/drm_nouveau/nouveau.c
@@ -0,0 +1,492 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdbool.h>
+#include <assert.h>
+#include <errno.h>
+#include <sys/mman.h>
+
+#include <xf86drm.h>
+#include <xf86atomic.h>
+#include "libdrm_lists.h"
+#include "nouveau_drm.h"
+
+#include "nouveau.h"
+#include "private.h"
+
+#ifdef DEBUG
+uint32_t nouveau_debug = 0;
+
+static void
+debug_init(char *args)
+{
+	if (args) {
+		int n = strtol(args, NULL, 0);
+		if (n >= 0)
+			nouveau_debug = n;
+	}
+}
+#endif
+
+/* this is the old libdrm's version of nouveau_device_wrap(), the symbol
+ * is kept here to prevent AIGLX from crashing if the DDX is linked against
+ * the new libdrm, but the DRI driver against the old
+ */
+int
+nouveau_device_open_existing(struct nouveau_device **pdev, int close, int fd,
+			     drm_context_t ctx)
+{
+	return -EACCES;
+}
+
+int
+nouveau_device_wrap(int fd, int close, struct nouveau_device **pdev)
+{
+	struct nouveau_device_priv *nvdev = calloc(1, sizeof(*nvdev));
+	struct nouveau_device *dev = &nvdev->base;
+	uint64_t chipset, vram, gart, bousage;
+	drmVersionPtr ver;
+	int ret;
+
+#ifdef DEBUG
+	debug_init(getenv("NOUVEAU_LIBDRM_DEBUG"));
+#endif
+
+	if (!nvdev)
+		return -ENOMEM;
+	nvdev->base.fd = fd;
+
+	ver = drmGetVersion(fd);
+	if (ver) dev->drm_version = (ver->version_major << 24) |
+				    (ver->version_minor << 8) |
+				     ver->version_patchlevel;
+	drmFreeVersion(ver);
+
+	if ( dev->drm_version != 0x00000010 &&
+	    (dev->drm_version <  0x01000000 ||
+	     dev->drm_version >= 0x02000000)) {
+		nouveau_device_del(&dev);
+		return -EINVAL;
+	}
+
+	ret = nouveau_getparam(dev, NOUVEAU_GETPARAM_CHIPSET_ID, &chipset);
+	if (ret == 0)
+	ret = nouveau_getparam(dev, NOUVEAU_GETPARAM_FB_SIZE, &vram);
+	if (ret == 0)
+	ret = nouveau_getparam(dev, NOUVEAU_GETPARAM_AGP_SIZE, &gart);
+	if (ret) {
+		nouveau_device_del(&dev);
+		return ret;
+	}
+
+	ret = nouveau_getparam(dev, NOUVEAU_GETPARAM_HAS_BO_USAGE, &bousage);
+	if (ret == 0)
+		nvdev->have_bo_usage = (bousage != 0);
+
+	nvdev->close = close;
+	DRMINITLISTHEAD(&nvdev->bo_list);
+	nvdev->base.object.oclass = NOUVEAU_DEVICE_CLASS;
+	nvdev->base.lib_version = 0x01000000;
+	nvdev->base.chipset = chipset;
+	nvdev->base.vram_size = vram;
+	nvdev->base.gart_size = gart;
+	nvdev->base.vram_limit = (nvdev->base.vram_size * 80) / 100;
+	nvdev->base.gart_limit = (nvdev->base.gart_size * 80) / 100;
+
+	*pdev = &nvdev->base;
+	return 0;
+}
+
+int
+nouveau_device_open(const char *busid, struct nouveau_device **pdev)
+{
+	int ret = -ENODEV, fd = drmOpen("nouveau", busid);
+	if (fd >= 0) {
+		ret = nouveau_device_wrap(fd, 1, pdev);
+		if (ret)
+			drmClose(fd);
+	}
+	return ret;
+}
+
+void
+nouveau_device_del(struct nouveau_device **pdev)
+{
+	struct nouveau_device_priv *nvdev = nouveau_device(*pdev);
+	if (nvdev) {
+		if (nvdev->close)
+			drmClose(nvdev->base.fd);
+		free(nvdev->client);
+		free(nvdev);
+		*pdev = NULL;
+	}
+}
+
+int
+nouveau_getparam(struct nouveau_device *dev, uint64_t param, uint64_t *value)
+{
+	struct drm_nouveau_getparam r = { param, 0 };
+	int fd = dev->fd, ret =
+		drmCommandWriteRead(fd, DRM_NOUVEAU_GETPARAM, &r, sizeof(r));
+	*value = r.value;
+	return ret;
+}
+
+int
+nouveau_setparam(struct nouveau_device *dev, uint64_t param, uint64_t value)
+{
+	struct drm_nouveau_setparam r = { param, value };
+	return drmCommandWrite(dev->fd, DRM_NOUVEAU_SETPARAM, &r, sizeof(r));
+}
+
+int
+nouveau_client_new(struct nouveau_device *dev, struct nouveau_client **pclient)
+{
+	struct nouveau_device_priv *nvdev = nouveau_device(dev);
+	struct nouveau_client_priv *pcli;
+	int id = 0, i, ret = -ENOMEM;
+	uint32_t *clients;
+
+	for (i = 0; i < nvdev->nr_client; i++) {
+		id = ffs(nvdev->client[i]) - 1;
+		if (id >= 0)
+			goto out;
+	}
+
+	clients = realloc(nvdev->client, sizeof(uint32_t) * (i + 1));
+	if (!clients)
+		return ret;
+	nvdev->client = clients;
+	nvdev->client[i] = 0;
+	nvdev->nr_client++;
+
+out:
+	pcli = calloc(1, sizeof(*pcli));
+	if (pcli) {
+		nvdev->client[i] |= (1 << id);
+		pcli->base.device = dev;
+		pcli->base.id = (i * 32) + id;
+		ret = 0;
+	}
+
+	*pclient = &pcli->base;
+	return ret;
+}
+
+void
+nouveau_client_del(struct nouveau_client **pclient)
+{
+	struct nouveau_client_priv *pcli = nouveau_client(*pclient);
+	struct nouveau_device_priv *nvdev;
+	if (pcli) {
+		int id = pcli->base.id;
+		nvdev = nouveau_device(pcli->base.device);
+		nvdev->client[id / 32] &= ~(1 << (id % 32));
+		free(pcli->kref);
+		free(pcli);
+	}
+}
+
+int
+nouveau_object_new(struct nouveau_object *parent, uint64_t handle,
+		   uint32_t oclass, void *data, uint32_t length,
+		   struct nouveau_object **pobj)
+{
+	struct nouveau_device *dev;
+	struct nouveau_object *obj;
+	int ret = -EINVAL;
+
+	if (length == 0)
+		length = sizeof(struct nouveau_object *);
+	obj = malloc(sizeof(*obj) + length);
+	obj->parent = parent;
+	obj->handle = handle;
+	obj->oclass = oclass;
+	obj->length = length;
+	obj->data = obj + 1;
+	if (data)
+		memcpy(obj->data, data, length);
+	*(struct nouveau_object **)obj->data = obj;
+
+	dev = nouveau_object_find(obj, NOUVEAU_DEVICE_CLASS);
+	switch (parent->oclass) {
+	case NOUVEAU_DEVICE_CLASS:
+		switch (obj->oclass) {
+		case NOUVEAU_FIFO_CHANNEL_CLASS:
+		{
+			if (dev->chipset < 0xc0)
+				ret = abi16_chan_nv04(obj);
+			else
+				ret = abi16_chan_nvc0(obj);
+		}
+			break;
+		default:
+			break;
+		}
+		break;
+	case NOUVEAU_FIFO_CHANNEL_CLASS:
+		switch (obj->oclass) {
+		case NOUVEAU_NOTIFIER_CLASS:
+			ret = abi16_ntfy(obj);
+			break;
+		default:
+			ret = abi16_engobj(obj);
+			break;
+		}
+	default:
+		break;
+	}
+
+	if (ret) {
+		free(obj);
+		return ret;
+	}
+
+	*pobj = obj;
+	return 0;
+}
+
+void
+nouveau_object_del(struct nouveau_object **pobj)
+{
+	struct nouveau_object *obj = *pobj;
+	struct nouveau_device *dev;
+	if (obj) {
+		dev = nouveau_object_find(obj, NOUVEAU_DEVICE_CLASS);
+		if (obj->oclass == NOUVEAU_FIFO_CHANNEL_CLASS) {
+			struct drm_nouveau_channel_free req;
+			req.channel = obj->handle;
+			drmCommandWrite(dev->fd, DRM_NOUVEAU_CHANNEL_FREE,
+					&req, sizeof(req));
+		} else {
+			struct drm_nouveau_gpuobj_free req;
+			req.channel = obj->parent->handle;
+			req.handle  = obj->handle;
+			drmCommandWrite(dev->fd, DRM_NOUVEAU_GPUOBJ_FREE,
+					&req, sizeof(req));
+		}
+	}
+	free(obj);
+	*pobj = NULL;
+}
+
+void *
+nouveau_object_find(struct nouveau_object *obj, uint32_t pclass)
+{
+	while (obj && obj->oclass != pclass) {
+		obj = obj->parent;
+		if (pclass == NOUVEAU_PARENT_CLASS)
+			break;
+	}
+	return obj;
+}
+
+static void
+nouveau_bo_del(struct nouveau_bo *bo)
+{
+	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
+	struct drm_gem_close req = { bo->handle };
+	DRMLISTDEL(&nvbo->head);
+	if (bo->map)
+		munmap(bo->map, bo->size);
+	drmIoctl(bo->device->fd, DRM_IOCTL_GEM_CLOSE, &req);
+	free(nvbo);
+}
+
+int
+nouveau_bo_new(struct nouveau_device *dev, uint32_t flags, uint32_t align,
+	       uint64_t size, union nouveau_bo_config *config,
+	       struct nouveau_bo **pbo)
+{
+	struct nouveau_device_priv *nvdev = nouveau_device(dev);
+	struct nouveau_bo_priv *nvbo = calloc(1, sizeof(*nvbo));
+	struct nouveau_bo *bo = &nvbo->base;
+	int ret;
+
+	if (!nvbo)
+		return -ENOMEM;
+	atomic_set(&nvbo->refcnt, 1);
+	bo->device = dev;
+	bo->flags = flags;
+	bo->size = size;
+
+	ret = abi16_bo_init(bo, align, config);
+	if (ret) {
+		free(nvbo);
+		return ret;
+	}
+
+	DRMLISTADD(&nvbo->head, &nvdev->bo_list);
+
+	*pbo = bo;
+	return 0;
+}
+
+int
+nouveau_bo_wrap(struct nouveau_device *dev, uint32_t handle,
+		struct nouveau_bo **pbo)
+{
+	struct nouveau_device_priv *nvdev = nouveau_device(dev);
+	struct drm_nouveau_gem_info req = { .handle = handle };
+	struct nouveau_bo_priv *nvbo;
+	int ret;
+
+	DRMLISTFOREACHENTRY(nvbo, &nvdev->bo_list, head) {
+		if (nvbo->base.handle == handle) {
+			*pbo = NULL;
+			nouveau_bo_ref(&nvbo->base, pbo);
+			return 0;
+		}
+	}
+
+	ret = drmCommandWriteRead(dev->fd, DRM_NOUVEAU_GEM_INFO,
+				  &req, sizeof(req));
+	if (ret)
+		return ret;
+
+	nvbo = calloc(1, sizeof(*nvbo));
+	if (nvbo) {
+		atomic_set(&nvbo->refcnt, 1);
+		nvbo->base.device = dev;
+		abi16_bo_info(&nvbo->base, &req);
+		DRMLISTADD(&nvbo->head, &nvdev->bo_list);
+		*pbo = &nvbo->base;
+		return 0;
+	}
+
+	return -ENOMEM;
+}
+
+int
+nouveau_bo_name_ref(struct nouveau_device *dev, uint32_t name,
+		    struct nouveau_bo **pbo)
+{
+	struct nouveau_device_priv *nvdev = nouveau_device(dev);
+	struct nouveau_bo_priv *nvbo;
+	struct drm_gem_open req = { .name = name };
+	int ret;
+
+	DRMLISTFOREACHENTRY(nvbo, &nvdev->bo_list, head) {
+		if (nvbo->name == name) {
+			*pbo = NULL;
+			nouveau_bo_ref(&nvbo->base, pbo);
+			return 0;
+		}
+	}
+
+	ret = drmIoctl(dev->fd, DRM_IOCTL_GEM_OPEN, &req);
+	if (ret == 0) {
+		ret = nouveau_bo_wrap(dev, req.handle, pbo);
+		nouveau_bo((*pbo))->name = name;
+	}
+
+	return ret;
+}
+
+int
+nouveau_bo_name_get(struct nouveau_bo *bo, uint32_t *name)
+{
+	struct drm_gem_flink req = { .handle = bo->handle };
+	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
+	if (!nvbo->name) {
+		int ret = drmIoctl(bo->device->fd, DRM_IOCTL_GEM_FLINK, &req);
+		if (ret)
+			return ret;
+		nvbo->name = req.name;
+	}
+	*name = nvbo->name;
+	return 0;
+}
+
+void
+nouveau_bo_ref(struct nouveau_bo *bo, struct nouveau_bo **pref)
+{
+	struct nouveau_bo *ref = *pref;
+	if (bo) {
+		atomic_inc(&nouveau_bo(bo)->refcnt);
+	}
+	if (ref) {
+		if (atomic_dec_and_test(&nouveau_bo(ref)->refcnt))
+			nouveau_bo_del(ref);
+	}
+	*pref = bo;
+}
+
+int
+nouveau_bo_wait(struct nouveau_bo *bo, uint32_t access,
+		struct nouveau_client *client)
+{
+	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
+	struct drm_nouveau_gem_cpu_prep req;
+	struct nouveau_pushbuf *push;
+	int ret = 0;
+
+	if (!(access & NOUVEAU_BO_RDWR))
+		return 0;
+
+	push = cli_push_get(client, bo);
+	if (push && push->channel)
+		nouveau_pushbuf_kick(push, push->channel);
+
+	if (!nvbo->name && !(nvbo->access & NOUVEAU_BO_WR) &&
+			   !(      access & NOUVEAU_BO_WR))
+		return 0;
+
+	req.handle = bo->handle;
+	req.flags = 0;
+	if (access & NOUVEAU_BO_WR)
+		req.flags |= NOUVEAU_GEM_CPU_PREP_WRITE;
+	if (access & NOUVEAU_BO_NOBLOCK)
+		req.flags |= NOUVEAU_GEM_CPU_PREP_NOWAIT;
+
+	ret = drmCommandWrite(bo->device->fd, DRM_NOUVEAU_GEM_CPU_PREP,
+			      &req, sizeof(req));
+	if (ret == 0)
+		nvbo->access = 0;
+	return ret;
+}
+
+int
+nouveau_bo_map(struct nouveau_bo *bo, uint32_t access,
+	       struct nouveau_client *client)
+{
+	struct nouveau_bo_priv *nvbo = nouveau_bo(bo);
+	if (bo->map == NULL) {
+		bo->map = mmap(0, bo->size, PROT_READ | PROT_WRITE,
+			       MAP_SHARED, bo->device->fd, nvbo->map_handle);
+		if (bo->map == MAP_FAILED) {
+			bo->map = NULL;
+			return -errno;
+		}
+	}
+	return nouveau_bo_wait(bo, access, client);
+}
diff --git a/drm_nouveau/nouveau.h b/drm_nouveau/nouveau.h
new file mode 100644
index 0000000..51a9598
--- /dev/null
+++ b/drm_nouveau/nouveau.h
@@ -0,0 +1,212 @@
+#ifndef __NOUVEAU_H__
+#define __NOUVEAU_H__
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#define NOUVEAU_DEVICE_CLASS       0x80000000
+#define NOUVEAU_FIFO_CHANNEL_CLASS 0x80000001
+#define NOUVEAU_NOTIFIER_CLASS     0x80000002
+#define NOUVEAU_PARENT_CLASS       0xffffffff
+
+struct nouveau_list {
+	struct nouveau_list *prev;
+	struct nouveau_list *next;
+};
+
+struct nouveau_object {
+	struct nouveau_object *parent;
+	uint64_t handle;
+	uint32_t oclass;
+	uint32_t length;
+	void *data;
+};
+
+struct nouveau_fifo {
+	struct nouveau_object *object;
+	uint32_t channel;
+	uint32_t pushbuf;
+	uint64_t unused1[3];
+};
+
+struct nv04_fifo {
+	struct nouveau_fifo base;
+	uint32_t vram;
+	uint32_t gart;
+	uint32_t notify;
+};
+
+struct nvc0_fifo {
+	struct nouveau_fifo base;
+	uint32_t notify;
+};
+
+struct nv04_notify {
+	struct nouveau_object *object;
+	uint32_t offset;
+	uint32_t length;
+};
+
+int  nouveau_object_new(struct nouveau_object *parent, uint64_t handle,
+			uint32_t oclass, void *data, uint32_t length,
+			struct nouveau_object **);
+void nouveau_object_del(struct nouveau_object **);
+void *nouveau_object_find(struct nouveau_object *, uint32_t parent_class);
+
+struct nouveau_device {
+	struct nouveau_object object;
+	int fd;
+	uint32_t lib_version;
+	uint32_t drm_version;
+	uint32_t chipset;
+	uint64_t vram_size;
+	uint64_t gart_size;
+	uint64_t vram_limit;
+	uint64_t gart_limit;
+};
+
+int  nouveau_device_wrap(int fd, int close, struct nouveau_device **);
+int  nouveau_device_open(const char *busid, struct nouveau_device **);
+void nouveau_device_del(struct nouveau_device **);
+int  nouveau_getparam(struct nouveau_device *, uint64_t param, uint64_t *value);
+int  nouveau_setparam(struct nouveau_device *, uint64_t param, uint64_t value);
+
+struct nouveau_client {
+	struct nouveau_device *device;
+	int id;
+};
+
+int  nouveau_client_new(struct nouveau_device *, struct nouveau_client **);
+void nouveau_client_del(struct nouveau_client **);
+
+union nouveau_bo_config {
+	struct {
+#define NV04_BO_16BPP 0x00000001
+#define NV04_BO_32BPP 0x00000002
+#define NV04_BO_ZETA  0x00000004
+		uint32_t surf_flags;
+		uint32_t surf_pitch;
+	} nv04;
+	struct {
+		uint32_t memtype;
+		uint32_t tile_mode;
+	} nv50;
+	struct {
+		uint32_t memtype;
+		uint32_t tile_mode;
+	} nvc0;
+	uint32_t data[8];
+};
+
+#define NOUVEAU_BO_VRAM    0x00000001
+#define NOUVEAU_BO_GART    0x00000002
+#define NOUVEAU_BO_APER   (NOUVEAU_BO_VRAM | NOUVEAU_BO_GART)
+#define NOUVEAU_BO_RD      0x00000100
+#define NOUVEAU_BO_WR      0x00000200
+#define NOUVEAU_BO_RDWR   (NOUVEAU_BO_RD | NOUVEAU_BO_WR)
+#define NOUVEAU_BO_NOBLOCK 0x00000400
+#define NOUVEAU_BO_LOW     0x00001000
+#define NOUVEAU_BO_HIGH    0x00002000
+#define NOUVEAU_BO_OR      0x00004000
+#define NOUVEAU_BO_MAP     0x80000000
+#define NOUVEAU_BO_CONTIG  0x40000000
+#define NOUVEAU_BO_NOSNOOP 0x20000000
+
+struct nouveau_bo {
+	struct nouveau_device *device;
+	uint32_t handle;
+	uint64_t size;
+	uint32_t flags;
+	uint64_t offset;
+	void *map;
+	union nouveau_bo_config config;
+};
+
+int  nouveau_bo_new(struct nouveau_device *, uint32_t flags, uint32_t align,
+		    uint64_t size, union nouveau_bo_config *,
+		    struct nouveau_bo **);
+int  nouveau_bo_wrap(struct nouveau_device *, uint32_t handle,
+		     struct nouveau_bo **);
+int  nouveau_bo_name_ref(struct nouveau_device *dev, uint32_t name,
+			 struct nouveau_bo **);
+int  nouveau_bo_name_get(struct nouveau_bo *, uint32_t *name);
+void nouveau_bo_ref(struct nouveau_bo *, struct nouveau_bo **);
+int  nouveau_bo_map(struct nouveau_bo *, uint32_t access,
+		    struct nouveau_client *);
+int  nouveau_bo_wait(struct nouveau_bo *, uint32_t access,
+		     struct nouveau_client *);
+
+struct nouveau_bufref {
+	struct nouveau_list thead;
+	struct nouveau_bo *bo;
+	uint32_t packet;
+	uint32_t flags;
+	uint32_t data;
+	uint32_t vor;
+	uint32_t tor;
+	uint32_t priv_data;
+	void *priv;
+};
+
+struct nouveau_bufctx {
+	struct nouveau_client *client;
+	struct nouveau_list head;
+	struct nouveau_list pending;
+	struct nouveau_list current;
+	int relocs;
+};
+
+int  nouveau_bufctx_new(struct nouveau_client *, int bins,
+			struct nouveau_bufctx **);
+void nouveau_bufctx_del(struct nouveau_bufctx **);
+struct nouveau_bufref *
+nouveau_bufctx_refn(struct nouveau_bufctx *, int bin,
+		    struct nouveau_bo *, uint32_t flags);
+struct nouveau_bufref *
+nouveau_bufctx_mthd(struct nouveau_bufctx *, int bin,  uint32_t packet,
+		    struct nouveau_bo *, uint64_t data, uint32_t flags,
+		    uint32_t vor, uint32_t tor);
+void nouveau_bufctx_reset(struct nouveau_bufctx *, int bin);
+
+struct nouveau_pushbuf_krec;
+struct nouveau_pushbuf {
+	struct nouveau_client *client;
+	struct nouveau_object *channel;
+	struct nouveau_bufctx *bufctx;
+	void (*kick_notify)(struct nouveau_pushbuf *);
+	void *user_priv;
+	uint32_t rsvd_kick;
+	uint32_t flags;
+	uint32_t *cur;
+	uint32_t *end;
+};
+
+struct nouveau_pushbuf_refn {
+	struct nouveau_bo *bo;
+	uint32_t flags;
+};
+
+int  nouveau_pushbuf_new(struct nouveau_client *, struct nouveau_object *channel,
+			 int nr, uint32_t size, bool immediate,
+			 struct nouveau_pushbuf **);
+void nouveau_pushbuf_del(struct nouveau_pushbuf **);
+int  nouveau_pushbuf_space(struct nouveau_pushbuf *, uint32_t dwords,
+			   uint32_t relocs, uint32_t pushes);
+void nouveau_pushbuf_data(struct nouveau_pushbuf *, struct nouveau_bo *,
+			  uint64_t offset, uint64_t length);
+int  nouveau_pushbuf_refn(struct nouveau_pushbuf *,
+			  struct nouveau_pushbuf_refn *, int nr);
+/* Emits a reloc into the push buffer at the current position, you *must*
+ * have previously added the referenced buffer to a buffer context, and
+ * validated it against the current push buffer.
+ */
+void nouveau_pushbuf_reloc(struct nouveau_pushbuf *, struct nouveau_bo *,
+			   uint32_t data, uint32_t flags,
+			   uint32_t vor, uint32_t tor);
+int  nouveau_pushbuf_validate(struct nouveau_pushbuf *);
+uint32_t nouveau_pushbuf_refd(struct nouveau_pushbuf *, struct nouveau_bo *);
+int  nouveau_pushbuf_kick(struct nouveau_pushbuf *, struct nouveau_object *channel);
+struct nouveau_bufctx *
+nouveau_pushbuf_bufctx(struct nouveau_pushbuf *, struct nouveau_bufctx *);
+
+#endif
diff --git a/drm_nouveau/private.h b/drm_nouveau/private.h
new file mode 100644
index 0000000..b409cc8
--- /dev/null
+++ b/drm_nouveau/private.h
@@ -0,0 +1,122 @@
+#ifndef __NOUVEAU_LIBDRM_PRIVATE_H__
+#define __NOUVEAU_LIBDRM_PRIVATE_H__
+
+#include <xf86drm.h>
+#include <xf86atomic.h>
+#include "nouveau_drm.h"
+
+#include "nouveau.h"
+
+#ifdef DEBUG
+uint32_t nouveau_debug;
+#define dbg_on(lvl) (nouveau_debug & (1 << lvl))
+#define dbg(lvl, fmt, args...) do {                                            \
+	if (dbg_on((lvl)))                                                     \
+		fprintf(stderr, "nouveau: "fmt, ##args);                       \
+} while(0)
+#else
+#define dbg_on(lvl) (0)
+#define dbg(lvl, fmt, args...)
+#endif
+#define err(fmt, args...) fprintf(stderr, "nouveau: "fmt, ##args)
+
+struct nouveau_client_kref {
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+	struct nouveau_pushbuf *push;
+};
+
+struct nouveau_client_priv {
+	struct nouveau_client base;
+	struct nouveau_client_kref *kref;
+	unsigned kref_nr;
+};
+
+static inline struct nouveau_client_priv *
+nouveau_client(struct nouveau_client *client)
+{
+	return (struct nouveau_client_priv *)client;
+}
+
+static inline struct drm_nouveau_gem_pushbuf_bo *
+cli_kref_get(struct nouveau_client *client, struct nouveau_bo *bo)
+{
+	struct nouveau_client_priv *pcli = nouveau_client(client);
+	struct drm_nouveau_gem_pushbuf_bo *kref = NULL;
+	if (pcli->kref_nr > bo->handle)
+		kref = pcli->kref[bo->handle].kref;
+	return kref;
+}
+
+static inline struct nouveau_pushbuf *
+cli_push_get(struct nouveau_client *client, struct nouveau_bo *bo)
+{
+	struct nouveau_client_priv *pcli = nouveau_client(client);
+	struct nouveau_pushbuf *push = NULL;
+	if (pcli->kref_nr > bo->handle)
+		push = pcli->kref[bo->handle].push;
+	return push;
+}
+
+static inline void
+cli_kref_set(struct nouveau_client *client, struct nouveau_bo *bo,
+	     struct drm_nouveau_gem_pushbuf_bo *kref,
+	     struct nouveau_pushbuf *push)
+{
+	struct nouveau_client_priv *pcli = nouveau_client(client);
+	if (pcli->kref_nr <= bo->handle) {
+		pcli->kref = realloc(pcli->kref,
+				     sizeof(*pcli->kref) * bo->handle * 2);
+		while (pcli->kref_nr < bo->handle * 2) {
+			pcli->kref[pcli->kref_nr].kref = NULL;
+			pcli->kref[pcli->kref_nr].push = NULL;
+			pcli->kref_nr++;
+		}
+	}
+	pcli->kref[bo->handle].kref = kref;
+	pcli->kref[bo->handle].push = push;
+}
+
+struct nouveau_bo_priv {
+	struct nouveau_bo base;
+	struct nouveau_list head;
+	atomic_t refcnt;
+	uint64_t map_handle;
+	uint32_t name;
+	uint32_t access;
+};
+
+static inline struct nouveau_bo_priv *
+nouveau_bo(struct nouveau_bo *bo)
+{
+	return (struct nouveau_bo_priv *)bo;
+}
+
+struct nouveau_device_priv {
+	struct nouveau_device base;
+	int close;
+	atomic_t lock;
+	struct nouveau_list bo_list;
+	uint32_t *client;
+	int nr_client;
+	bool have_bo_usage;
+};
+
+static inline struct nouveau_device_priv *
+nouveau_device(struct nouveau_device *dev)
+{
+	return (struct nouveau_device_priv *)dev;
+}
+
+int
+nouveau_device_open_existing(struct nouveau_device **, int, int, drm_context_t);
+
+/* abi16.c */
+int  abi16_chan_nv04(struct nouveau_object *);
+int  abi16_chan_nvc0(struct nouveau_object *);
+int  abi16_engobj(struct nouveau_object *);
+int  abi16_ntfy(struct nouveau_object *);
+void abi16_bo_info(struct nouveau_bo *, struct drm_nouveau_gem_info *);
+int  abi16_bo_init(struct nouveau_bo *, uint32_t alignment,
+		   union nouveau_bo_config *);
+
+#endif
diff --git a/drm_nouveau/pushbuf.c b/drm_nouveau/pushbuf.c
new file mode 100644
index 0000000..7b9dbaa
--- /dev/null
+++ b/drm_nouveau/pushbuf.c
@@ -0,0 +1,771 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+
+#include <xf86drm.h>
+#include <xf86atomic.h>
+#include "libdrm_lists.h"
+#include "nouveau_drm.h"
+
+#include "nouveau.h"
+#include "private.h"
+
+struct nouveau_pushbuf_krec {
+	struct nouveau_pushbuf_krec *next;
+	struct drm_nouveau_gem_pushbuf_bo buffer[NOUVEAU_GEM_MAX_BUFFERS];
+	struct drm_nouveau_gem_pushbuf_reloc reloc[NOUVEAU_GEM_MAX_RELOCS];
+	struct drm_nouveau_gem_pushbuf_push push[NOUVEAU_GEM_MAX_PUSH];
+	int nr_buffer;
+	int nr_reloc;
+	int nr_push;
+	uint64_t vram_used;
+	uint64_t gart_used;
+};
+
+struct nouveau_pushbuf_priv {
+	struct nouveau_pushbuf base;
+	struct nouveau_pushbuf_krec *list;
+	struct nouveau_pushbuf_krec *krec;
+	struct nouveau_list bctx_list;
+	struct nouveau_bo *bo;
+	uint32_t type;
+	uint32_t suffix0;
+	uint32_t suffix1;
+	uint32_t *ptr;
+	uint32_t *bgn;
+	int bo_next;
+	int bo_nr;
+	struct nouveau_bo *bos[];
+};
+
+static inline struct nouveau_pushbuf_priv *
+nouveau_pushbuf(struct nouveau_pushbuf *push)
+{
+	return (struct nouveau_pushbuf_priv *)push;
+}
+
+static int pushbuf_validate(struct nouveau_pushbuf *, bool);
+static int pushbuf_flush(struct nouveau_pushbuf *);
+
+static bool
+pushbuf_kref_fits(struct nouveau_pushbuf *push, struct nouveau_bo *bo,
+		  uint32_t *domains)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->krec;
+	struct nouveau_device *dev = push->client->device;
+	struct nouveau_bo *kbo;
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+	int i;
+
+	/* VRAM is the only valid domain.  GART and VRAM|GART buffers
+	 * are all accounted to GART, so if this doesn't fit in VRAM
+	 * straight up, a flush is needed.
+	 */
+	if (*domains == NOUVEAU_GEM_DOMAIN_VRAM) {
+		if (krec->vram_used + bo->size > dev->vram_limit)
+			return false;
+		krec->vram_used += bo->size;
+		return true;
+	}
+
+	/* GART or VRAM|GART buffer.  Account both of these buffer types
+	 * to GART only for the moment, which simplifies things.  If the
+	 * buffer can fit already, we're done here.
+	 */
+	if (krec->gart_used + bo->size <= dev->gart_limit) {
+		krec->gart_used += bo->size;
+		return true;
+	}
+
+	/* Ran out of GART space, if it's a VRAM|GART buffer and it'll
+	 * fit into available VRAM, turn it into a VRAM buffer
+	 */
+	if ((*domains & NOUVEAU_GEM_DOMAIN_VRAM) &&
+	    krec->vram_used + bo->size <= dev->vram_limit) {
+		*domains &= NOUVEAU_GEM_DOMAIN_VRAM;
+		krec->vram_used += bo->size;
+		return true;
+	}
+
+	/* Still couldn't fit the buffer in anywhere, so as a last resort;
+	 * scan the buffer list for VRAM|GART buffers and turn them into
+	 * VRAM buffers until we have enough space in GART for this one
+	 */
+	kref = krec->buffer;
+	for (i = 0; i < krec->nr_buffer; i++, kref++) {
+		if (!(kref->valid_domains & NOUVEAU_GEM_DOMAIN_GART))
+			continue;
+
+		kbo = (void *)(unsigned long)kref->user_priv;
+		if (!(kref->valid_domains & NOUVEAU_GEM_DOMAIN_VRAM) ||
+		    krec->vram_used + kbo->size > dev->vram_limit)
+			continue;
+
+		kref->valid_domains &= NOUVEAU_GEM_DOMAIN_VRAM;
+		krec->gart_used -= kbo->size;
+		krec->vram_used += kbo->size;
+		if (krec->gart_used + bo->size <= dev->gart_limit) {
+			krec->gart_used += bo->size;
+			return true;
+		}
+	}
+
+	/* Couldn't resolve a placement, need to force a flush */
+	return false;
+}
+
+static struct drm_nouveau_gem_pushbuf_bo *
+pushbuf_kref(struct nouveau_pushbuf *push, struct nouveau_bo *bo,
+	     uint32_t flags)
+{
+	struct nouveau_device *dev = push->client->device;
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->krec;
+	struct nouveau_pushbuf *fpush;
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+	uint32_t domains, domains_wr, domains_rd;
+
+	domains = 0;
+	if (flags & NOUVEAU_BO_VRAM)
+		domains |= NOUVEAU_GEM_DOMAIN_VRAM;
+	if (flags & NOUVEAU_BO_GART)
+		domains |= NOUVEAU_GEM_DOMAIN_GART;
+	domains_wr = domains * !!(flags & NOUVEAU_BO_WR);
+	domains_rd = domains * !!(flags & NOUVEAU_BO_RD);
+
+	/* if buffer is referenced on another pushbuf that is owned by the
+	 * same client, we need to flush the other pushbuf first to ensure
+	 * the correct ordering of commands
+	 */
+	fpush = cli_push_get(push->client, bo);
+	if (fpush && fpush != push)
+		pushbuf_flush(fpush);
+
+	kref = cli_kref_get(push->client, bo);
+	if (kref) {
+		/* possible conflict in memory types - flush and retry */
+		if (!(kref->valid_domains & domains))
+			return NULL;
+
+		/* VRAM|GART buffer turning into a VRAM buffer.  Make sure
+		 * it'll fit in VRAM and force a flush if not.
+		 */
+		if ((kref->valid_domains  & NOUVEAU_GEM_DOMAIN_GART) &&
+		    (            domains == NOUVEAU_GEM_DOMAIN_VRAM)) {
+			if (krec->vram_used + bo->size > dev->vram_limit)
+				return NULL;
+			krec->vram_used += bo->size;
+			krec->gart_used -= bo->size;
+		}
+
+		kref->valid_domains &= domains;
+		kref->write_domains |= domains_wr;
+		kref->read_domains  |= domains_rd;
+	} else {
+		if (krec->nr_buffer == NOUVEAU_GEM_MAX_BUFFERS ||
+		    !pushbuf_kref_fits(push, bo, &domains))
+			return NULL;
+
+		kref = &krec->buffer[krec->nr_buffer++];
+		kref->user_priv = (unsigned long)bo;
+		kref->handle = bo->handle;
+		kref->valid_domains = domains;
+		kref->write_domains = domains_wr;
+		kref->read_domains = domains_rd;
+		kref->presumed.valid = 1;
+		kref->presumed.offset = bo->offset;
+		if (bo->flags & NOUVEAU_BO_VRAM)
+			kref->presumed.domain = NOUVEAU_GEM_DOMAIN_VRAM;
+		else
+			kref->presumed.domain = NOUVEAU_GEM_DOMAIN_GART;
+
+		cli_kref_set(push->client, bo, kref, push);
+		atomic_inc(&nouveau_bo(bo)->refcnt);
+	}
+
+	return kref;
+}
+
+static uint32_t
+pushbuf_krel(struct nouveau_pushbuf *push, struct nouveau_bo *bo,
+	     uint32_t data, uint32_t flags, uint32_t vor, uint32_t tor)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->krec;
+	struct drm_nouveau_gem_pushbuf_reloc *krel;
+	struct drm_nouveau_gem_pushbuf_bo *pkref;
+	struct drm_nouveau_gem_pushbuf_bo *bkref;
+	uint32_t reloc = data;
+
+	pkref = cli_kref_get(push->client, nvpb->bo);
+	bkref = cli_kref_get(push->client, bo);
+	krel  = &krec->reloc[krec->nr_reloc++];
+
+	krel->reloc_bo_index = pkref - krec->buffer;
+	krel->reloc_bo_offset = (push->cur - nvpb->ptr) * 4;
+	krel->bo_index = bkref - krec->buffer;
+	krel->flags = 0;
+	krel->data = data;
+	krel->vor = vor;
+	krel->tor = tor;
+
+	if (flags & NOUVEAU_BO_LOW) {
+		reloc = (bkref->presumed.offset + data);
+		krel->flags |= NOUVEAU_GEM_RELOC_LOW;
+	} else
+	if (flags & NOUVEAU_BO_HIGH) {
+		reloc = (bkref->presumed.offset + data) >> 32;
+		krel->flags |= NOUVEAU_GEM_RELOC_HIGH;
+	}
+	if (flags & NOUVEAU_BO_OR) {
+		if (bkref->presumed.domain & NOUVEAU_GEM_DOMAIN_VRAM)
+			reloc |= vor;
+		else
+			reloc |= tor;
+		krel->flags |= NOUVEAU_GEM_RELOC_OR;
+	}
+
+	return reloc;
+}
+
+static void
+pushbuf_dump(struct nouveau_pushbuf_krec *krec, int krec_id, int chid)
+{
+	struct drm_nouveau_gem_pushbuf_reloc *krel;
+	struct drm_nouveau_gem_pushbuf_push *kpsh;
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+	struct nouveau_bo *bo;
+	uint32_t *bgn, *end;
+	int i;
+
+	err("ch%d: krec %d pushes %d bufs %d relocs %d\n", chid,
+	    krec_id, krec->nr_push, krec->nr_buffer, krec->nr_reloc);
+
+	kref = krec->buffer;
+	for (i = 0; i < krec->nr_buffer; i++, kref++) {
+		err("ch%d: buf %08x %08x %08x %08x %08x\n", chid, i,
+		    kref->handle, kref->valid_domains,
+		    kref->read_domains, kref->write_domains);
+	}
+
+	krel = krec->reloc;
+	for (i = 0; i < krec->nr_reloc; i++, krel++) {
+		err("ch%d: rel %08x %08x %08x %08x %08x %08x %08x\n",
+		    chid, krel->reloc_bo_index, krel->reloc_bo_offset,
+		    krel->bo_index, krel->flags, krel->data,
+		    krel->vor, krel->tor);
+	}
+
+	kpsh = krec->push;
+	for (i = 0; i < krec->nr_push; i++, kpsh++) {
+		kref = krec->buffer + kpsh->bo_index;
+		bo = (void *)(unsigned long)kref->user_priv;
+		bgn = (uint32_t *)((char *)bo->map + kpsh->offset);
+		end = bgn + (kpsh->length /4);
+
+		err("ch%d: psh %08x %010llx %010llx\n", chid, kpsh->bo_index,
+		    (unsigned long long)kpsh->offset,
+		    (unsigned long long)(kpsh->offset + kpsh->length));
+		while (bgn < end)
+			err("\t0x%08x\n", *bgn++);
+	}
+}
+
+static int
+pushbuf_submit(struct nouveau_pushbuf *push, struct nouveau_object *chan)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->list;
+	struct nouveau_device *dev = push->client->device;
+	struct drm_nouveau_gem_pushbuf_bo_presumed *info;
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+	struct drm_nouveau_gem_pushbuf req;
+	struct nouveau_fifo *fifo = chan->data;
+	struct nouveau_bo *bo;
+	int krec_id = 0;
+	int ret = 0, i;
+
+	if (chan->oclass != NOUVEAU_FIFO_CHANNEL_CLASS)
+		return -EINVAL;
+
+	if (push->kick_notify)
+		push->kick_notify(push);
+
+	nouveau_pushbuf_data(push, NULL, 0, 0);
+
+	while (krec && krec->nr_push) {
+		req.channel = fifo->channel;
+		req.nr_buffers = krec->nr_buffer;
+		req.buffers = (uint64_t)(unsigned long)krec->buffer;
+		req.nr_relocs = krec->nr_reloc;
+		req.nr_push = krec->nr_push;
+		req.relocs = (uint64_t)(unsigned long)krec->reloc;
+		req.push = (uint64_t)(unsigned long)krec->push;
+		req.suffix0 = nvpb->suffix0;
+		req.suffix1 = nvpb->suffix1;
+
+		if (dbg_on(0))
+			pushbuf_dump(krec, krec_id++, fifo->channel);
+
+#ifndef SIMULATE
+		ret = drmCommandWriteRead(dev->fd, DRM_NOUVEAU_GEM_PUSHBUF,
+					  &req, sizeof(req));
+		nvpb->suffix0 = req.suffix0;
+		nvpb->suffix1 = req.suffix1;
+		dev->vram_limit = (req.vram_available * 80) / 100;
+		dev->gart_limit = (req.gart_available * 80) / 100;
+#else
+		if (dbg_on(31))
+			ret = -EINVAL;
+#endif
+
+		if (ret) {
+			err("kernel rejected pushbuf: %s\n", strerror(-ret));
+			pushbuf_dump(krec, krec_id++, fifo->channel);
+			break;
+		}
+
+		kref = krec->buffer;
+		for (i = 0; i < krec->nr_buffer; i++, kref++) {
+			bo = (void *)(unsigned long)kref->user_priv;
+
+			info = &kref->presumed;
+			if (!info->valid) {
+				bo->flags &= ~NOUVEAU_BO_APER;
+				if (info->domain == NOUVEAU_GEM_DOMAIN_VRAM)
+					bo->flags |= NOUVEAU_BO_VRAM;
+				else
+					bo->flags |= NOUVEAU_BO_GART;
+				bo->offset = info->offset;
+			}
+
+			if (kref->write_domains)
+				nouveau_bo(bo)->access |= NOUVEAU_BO_WR;
+			if (kref->read_domains)
+				nouveau_bo(bo)->access |= NOUVEAU_BO_RD;
+		}
+
+		krec = krec->next;
+	}
+
+	return ret;
+}
+
+static int
+pushbuf_flush(struct nouveau_pushbuf *push)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->krec;
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+	struct nouveau_bufctx *bctx, *btmp;
+	struct nouveau_bo *bo;
+	int ret = 0, i;
+
+	if (push->channel) {
+		ret = pushbuf_submit(push, push->channel);
+	} else {
+		nouveau_pushbuf_data(push, NULL, 0, 0);
+		krec->next = malloc(sizeof(*krec));
+		nvpb->krec = krec->next;
+	}
+
+	kref = krec->buffer;
+	for (i = 0; i < krec->nr_buffer; i++, kref++) {
+		bo = (void *)(unsigned long)kref->user_priv;
+		cli_kref_set(push->client, bo, NULL, NULL);
+		if (push->channel)
+			nouveau_bo_ref(NULL, &bo);
+	}
+
+	krec = nvpb->krec;
+	krec->vram_used = 0;
+	krec->gart_used = 0;
+	krec->nr_buffer = 0;
+	krec->nr_reloc = 0;
+	krec->nr_push = 0;
+
+	DRMLISTFOREACHENTRYSAFE(bctx, btmp, &nvpb->bctx_list, head) {
+		DRMLISTJOIN(&bctx->current, &bctx->pending);
+		DRMINITLISTHEAD(&bctx->current);
+		DRMLISTDELINIT(&bctx->head);
+	}
+
+	return ret;
+}
+
+static void
+pushbuf_refn_fail(struct nouveau_pushbuf *push, int sref, int srel)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->krec;
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+
+	kref = krec->buffer + sref;
+	while (krec->nr_buffer-- > sref) {
+		struct nouveau_bo *bo = (void *)(unsigned long)kref->user_priv;
+		cli_kref_set(push->client, bo, NULL, NULL);
+		nouveau_bo_ref(NULL, &bo);
+		kref++;
+	}
+	krec->nr_buffer = sref;
+	krec->nr_reloc = srel;
+}
+
+static int
+pushbuf_refn(struct nouveau_pushbuf *push, bool retry,
+	     struct nouveau_pushbuf_refn *refs, int nr)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->krec;
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+	int sref = krec->nr_buffer;
+	int ret = 0, i;
+
+	for (i = 0; i < nr; i++) {
+		kref = pushbuf_kref(push, refs[i].bo, refs[i].flags);
+		if (!kref) {
+			ret = -ENOSPC;
+			break;
+		}
+	}
+
+	if (ret) {
+		pushbuf_refn_fail(push, sref, krec->nr_reloc);
+		if (retry) {
+			pushbuf_flush(push);
+			nouveau_pushbuf_space(push, 0, 0, 0);
+			return pushbuf_refn(push, false, refs, nr);
+		}
+	}
+
+	return ret;
+}
+
+static int
+pushbuf_validate(struct nouveau_pushbuf *push, bool retry)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->krec;
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+	struct nouveau_bufctx *bctx = push->bufctx;
+	struct nouveau_bufref *bref;
+	int relocs = bctx ? bctx->relocs * 2: 0;
+	int sref, srel, ret;
+
+	ret = nouveau_pushbuf_space(push, relocs, relocs, 0);
+	if (ret || bctx == NULL)
+		return ret;
+
+	sref = krec->nr_buffer;
+	srel = krec->nr_reloc;
+
+	DRMLISTDEL(&bctx->head);
+	DRMLISTADD(&bctx->head, &nvpb->bctx_list);
+
+	DRMLISTFOREACHENTRY(bref, &bctx->pending, thead) {
+		kref = pushbuf_kref(push, bref->bo, bref->flags);
+		if (!kref) {
+			ret = -ENOSPC;
+			break;
+		}
+
+		if (bref->packet) {
+			pushbuf_krel(push, bref->bo, bref->packet, 0, 0, 0);
+			*push->cur++ = 0;
+			pushbuf_krel(push, bref->bo, bref->data, bref->flags,
+					   bref->vor, bref->tor);
+			*push->cur++ = 0;
+		}
+	}
+
+	DRMLISTJOIN(&bctx->pending, &bctx->current);
+	DRMINITLISTHEAD(&bctx->pending);
+
+	if (ret) {
+		pushbuf_refn_fail(push, sref, srel);
+		if (retry) {
+			pushbuf_flush(push);
+			return pushbuf_validate(push, false);
+		}
+	}
+
+	return 0;
+}
+
+int
+nouveau_pushbuf_new(struct nouveau_client *client, struct nouveau_object *chan,
+		    int nr, uint32_t size, bool immediate,
+		    struct nouveau_pushbuf **ppush)
+{
+	struct nouveau_device *dev = client->device;
+	struct nouveau_fifo *fifo = chan->data;
+	struct nouveau_pushbuf_priv *nvpb;
+	struct nouveau_pushbuf *push;
+	struct drm_nouveau_gem_pushbuf req;
+	int ret;
+
+	if (chan->oclass != NOUVEAU_FIFO_CHANNEL_CLASS)
+		return -EINVAL;
+
+	/* nop pushbuf call, to get the current "return to main" sequence
+	 * we need to append to the pushbuf on early chipsets
+	 */
+	req.channel = fifo->channel;
+	req.nr_push = 0;
+	ret = drmCommandWriteRead(dev->fd, DRM_NOUVEAU_GEM_PUSHBUF,
+				  &req, sizeof(req));
+	if (ret)
+		return ret;
+
+	nvpb = calloc(1, sizeof(*nvpb) + nr * sizeof(*nvpb->bos));
+	if (!nvpb)
+		return -ENOMEM;
+
+#ifndef SIMULATE
+	nvpb->suffix0 = req.suffix0;
+	nvpb->suffix1 = req.suffix1;
+#else
+	nvpb->suffix0 = 0xffffffff;
+	nvpb->suffix1 = 0xffffffff;
+#endif
+	nvpb->krec = calloc(1, sizeof(*nvpb->krec));
+	nvpb->list = nvpb->krec;
+	if (!nvpb->krec) {
+		free(nvpb);
+		return -ENOMEM;
+	}
+
+	push = &nvpb->base;
+	push->client = client;
+	push->channel = immediate ? chan : NULL;
+	push->flags = NOUVEAU_BO_RD;
+	if (fifo->pushbuf & NOUVEAU_GEM_DOMAIN_VRAM) {
+		push->flags |= NOUVEAU_BO_VRAM;
+		nvpb->type   = NOUVEAU_BO_VRAM;
+	}
+	if (fifo->pushbuf & NOUVEAU_GEM_DOMAIN_GART) {
+		push->flags |= NOUVEAU_BO_GART;
+		nvpb->type   = NOUVEAU_BO_GART;
+	}
+	nvpb->type |= NOUVEAU_BO_MAP;
+
+	for (nvpb->bo_nr = 0; nvpb->bo_nr < nr; nvpb->bo_nr++) {
+		ret = nouveau_bo_new(client->device, nvpb->type, 0, size,
+				     NULL, &nvpb->bos[nvpb->bo_nr]);
+		if (ret) {
+			nouveau_pushbuf_del(&push);
+			return ret;
+		}
+	}
+
+	DRMINITLISTHEAD(&nvpb->bctx_list);
+	*ppush = push;
+	return 0;
+}
+
+void
+nouveau_pushbuf_del(struct nouveau_pushbuf **ppush)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(*ppush);
+	if (nvpb) {
+		struct drm_nouveau_gem_pushbuf_bo *kref;
+		struct nouveau_pushbuf_krec *krec;
+		while ((krec = nvpb->list)) {
+			kref = krec->buffer;
+			while (krec->nr_buffer--) {
+				unsigned long priv = kref++->user_priv;
+				struct nouveau_bo *bo = (void *)priv;
+				cli_kref_set(nvpb->base.client, bo, NULL, NULL);
+				nouveau_bo_ref(NULL, &bo);
+			}
+			nvpb->list = krec->next;
+			free(krec);
+		}
+		while (nvpb->bo_nr--)
+			nouveau_bo_ref(NULL, &nvpb->bos[nvpb->bo_nr]);
+		nouveau_bo_ref(NULL, &nvpb->bo);
+		free(nvpb);
+	}
+	*ppush = NULL;
+}
+
+struct nouveau_bufctx *
+nouveau_pushbuf_bufctx(struct nouveau_pushbuf *push, struct nouveau_bufctx *ctx)
+{
+	struct nouveau_bufctx *prev = push->bufctx;
+	push->bufctx = ctx;
+	return prev;
+}
+
+int
+nouveau_pushbuf_space(struct nouveau_pushbuf *push,
+		      uint32_t dwords, uint32_t relocs, uint32_t pushes)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->krec;
+	struct nouveau_client *client = push->client;
+	struct nouveau_bo *bo = NULL;
+	bool flushed = false;
+	int ret = 0;
+
+	/* switch to next buffer if insufficient space in the current one */
+	if (push->cur + dwords >= push->end) {
+		if (nvpb->bo_next < nvpb->bo_nr) {
+			nouveau_bo_ref(nvpb->bos[nvpb->bo_next++], &bo);
+			if (nvpb->bo_next == nvpb->bo_nr && push->channel)
+				nvpb->bo_next = 0;
+		} else {
+			ret = nouveau_bo_new(client->device, nvpb->type, 0,
+					     nvpb->bos[0]->size, NULL, &bo);
+			if (ret)
+				return ret;
+		}
+	}
+
+	/* make sure there's always enough space to queue up the pending
+	 * data in the pushbuf proper
+	 */
+	pushes++;
+
+	/* need to flush if we've run out of space on an immediate pushbuf,
+	 * if the new buffer won't fit, or if the kernel push/reloc limits
+	 * have been hit
+	 */
+	if ((bo && ( push->channel ||
+		    !pushbuf_kref(push, bo, push->flags))) ||
+	    krec->nr_reloc + relocs >= NOUVEAU_GEM_MAX_RELOCS ||
+	    krec->nr_push + pushes >= NOUVEAU_GEM_MAX_PUSH) {
+		if (nvpb->bo && krec->nr_buffer)
+			pushbuf_flush(push);
+		flushed = true;
+	}
+
+	/* if necessary, switch to new buffer */
+	if (bo) {
+		ret = nouveau_bo_map(bo, NOUVEAU_BO_WR, push->client);
+		if (ret)
+			return ret;
+
+		nouveau_pushbuf_data(push, NULL, 0, 0);
+		nouveau_bo_ref(bo, &nvpb->bo);
+		nouveau_bo_ref(NULL, &bo);
+
+		nvpb->bgn = nvpb->bo->map;
+		nvpb->ptr = nvpb->bgn;
+		push->cur = nvpb->bgn;
+		push->end = push->cur + (nvpb->bo->size / 4);
+		push->end -= 2 + push->rsvd_kick; /* space for suffix */
+	}
+
+	pushbuf_kref(push, nvpb->bo, push->flags);
+	return flushed ? pushbuf_validate(push, false) : 0;
+}
+
+void
+nouveau_pushbuf_data(struct nouveau_pushbuf *push, struct nouveau_bo *bo,
+		     uint64_t offset, uint64_t length)
+{
+	struct nouveau_pushbuf_priv *nvpb = nouveau_pushbuf(push);
+	struct nouveau_pushbuf_krec *krec = nvpb->krec;
+	struct drm_nouveau_gem_pushbuf_push *kpsh;
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+
+	if (bo != nvpb->bo && nvpb->bgn != push->cur) {
+		if (nvpb->suffix0 || nvpb->suffix1) {
+			*push->cur++ = nvpb->suffix0;
+			*push->cur++ = nvpb->suffix1;
+		}
+
+		nouveau_pushbuf_data(push, nvpb->bo,
+				     (nvpb->bgn - nvpb->ptr) * 4,
+				     (push->cur - nvpb->bgn) * 4);
+		nvpb->bgn = push->cur;
+	}
+
+	if (bo) {
+		kref = cli_kref_get(push->client, bo);
+		kpsh = &krec->push[krec->nr_push++];
+		kpsh->bo_index = kref - krec->buffer;
+		kpsh->offset   = offset;
+		kpsh->length   = length;
+	}
+}
+
+int
+nouveau_pushbuf_refn(struct nouveau_pushbuf *push,
+		     struct nouveau_pushbuf_refn *refs, int nr)
+{
+	return pushbuf_refn(push, true, refs, nr);
+}
+
+void
+nouveau_pushbuf_reloc(struct nouveau_pushbuf *push, struct nouveau_bo *bo,
+		      uint32_t data, uint32_t flags, uint32_t vor, uint32_t tor)
+{
+	*push->cur++ = pushbuf_krel(push, bo, data, flags, vor, tor);
+}
+
+int
+nouveau_pushbuf_validate(struct nouveau_pushbuf *push)
+{
+	return pushbuf_validate(push, true);
+}
+
+uint32_t
+nouveau_pushbuf_refd(struct nouveau_pushbuf *push, struct nouveau_bo *bo)
+{
+	struct drm_nouveau_gem_pushbuf_bo *kref;
+	uint32_t flags = 0;
+
+	if (cli_push_get(push->client, bo) == push) {
+		kref = cli_kref_get(push->client, bo);
+		if (kref->read_domains)
+			flags |= NOUVEAU_BO_RD;
+		if (kref->write_domains)
+			flags |= NOUVEAU_BO_WR;
+	}
+
+	return flags;
+}
+
+int
+nouveau_pushbuf_kick(struct nouveau_pushbuf *push, struct nouveau_object *chan)
+{
+	if (!push->channel)
+		return pushbuf_submit(push, chan);
+	pushbuf_flush(push);
+	return pushbuf_validate(push, false);
+}
diff --git a/drm_nouveau/xf86atomic.h b/drm_nouveau/xf86atomic.h
new file mode 100644
index 0000000..db2f619
--- /dev/null
+++ b/drm_nouveau/xf86atomic.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright  2009 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Chris Wilson <chris@chris-wilson.co.uk>
+ *
+ */
+
+/**
+ * @file xf86atomics.h
+ *
+ * Private definitions for atomic operations
+ */
+
+#ifndef LIBDRM_ATOMICS_H
+#define LIBDRM_ATOMICS_H
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#if HAVE_LIBDRM_ATOMIC_PRIMITIVES
+
+#define HAS_ATOMIC_OPS 1
+
+typedef struct {
+	int atomic;
+} atomic_t;
+
+# define atomic_read(x) ((x)->atomic)
+# define atomic_set(x, val) ((x)->atomic = (val))
+# define atomic_inc(x) ((void) __sync_fetch_and_add (&(x)->atomic, 1))
+# define atomic_dec_and_test(x) (__sync_fetch_and_add (&(x)->atomic, -1) == 1)
+# define atomic_add(x, v) ((void) __sync_add_and_fetch(&(x)->atomic, (v)))
+# define atomic_dec(x, v) ((void) __sync_sub_and_fetch(&(x)->atomic, (v)))
+# define atomic_cmpxchg(x, oldv, newv) __sync_val_compare_and_swap (&(x)->atomic, oldv, newv)
+
+#endif
+
+#if HAVE_LIB_ATOMIC_OPS
+#include <atomic_ops.h>
+
+#define HAS_ATOMIC_OPS 1
+
+typedef struct {
+	AO_t atomic;
+} atomic_t;
+
+# define atomic_read(x) AO_load_full(&(x)->atomic)
+# define atomic_set(x, val) AO_store_full(&(x)->atomic, (val))
+# define atomic_inc(x) ((void) AO_fetch_and_add1_full(&(x)->atomic))
+# define atomic_add(x, v) ((void) AO_fetch_and_add_full(&(x)->atomic, (v)))
+# define atomic_dec(x, v) ((void) AO_fetch_and_add_full(&(x)->atomic, -(v)))
+# define atomic_dec_and_test(x) (AO_fetch_and_sub1_full(&(x)->atomic) == 1)
+# define atomic_cmpxchg(x, oldv, newv) AO_compare_and_swap_full(&(x)->atomic, oldv, newv)
+
+#endif
+
+#if defined(__sun) && !defined(HAS_ATOMIC_OPS)  /* Solaris & OpenSolaris */
+
+#include <sys/atomic.h>
+#define HAS_ATOMIC_OPS 1
+
+typedef struct { uint_t atomic; } atomic_t;
+
+# define atomic_read(x) (int) ((x)->atomic)
+# define atomic_set(x, val) ((x)->atomic = (uint_t)(val))
+# define atomic_inc(x) (atomic_inc_uint (&(x)->atomic))
+# define atomic_dec_and_test(x) (atomic_dec_uint_nv(&(x)->atomic) == 1)
+# define atomic_add(x, v) (atomic_add_int(&(x)->atomic, (v)))
+# define atomic_dec(x, v) (atomic_add_int(&(x)->atomic, -(v)))
+# define atomic_cmpxchg(x, oldv, newv) atomic_cas_uint (&(x)->atomic, oldv, newv)
+
+#endif
+
+#if ! HAS_ATOMIC_OPS
+#error libdrm requires atomic operations, please define them for your CPU/compiler.
+#endif
+
+#endif
diff --git a/src/Makefile.am b/src/Makefile.am
index 0bdd780..aa3eb59 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -23,13 +23,16 @@
 # -avoid-version prevents gratuitous .0.0.0 version numbers on the end
 # _ladir passes a dummy rpath to libtool so the thing will actually link
 # TODO: -nostdlib/-Bstatic/-lgcc platform magic, not installing the .a, etc.
-AM_CFLAGS = @XORG_CFLAGS@ @LIBUDEV_CFLAGS@ @LIBDRM_NOUVEAU_CFLAGS@
+AM_CFLAGS = @XORG_CFLAGS@ @LIBUDEV_CFLAGS@ @LIBDRM_NOUVEAU_CFLAGS@ \
+	    -I$(top_srcdir)/drm_nouveau -DHAVE_LIBDRM_ATOMIC_PRIMITIVES
 nouveau_drv_la_LTLIBRARIES = nouveau_drv.la
 nouveau_drv_la_LDFLAGS = -module -avoid-version @LIBDRM_NOUVEAU_LIBS@ \
 			 @LIBUDEV_LIBS@
 nouveau_drv_ladir = @moduledir@/drivers
 
 nouveau_drv_la_SOURCES = \
+			 ../drm_nouveau/abi16.c ../drm_nouveau/bufctx.c \
+			 ../drm_nouveau/nouveau.c ../drm_nouveau/pushbuf.c \
 			 nouveau_class.h nouveau_local.h \
 			 nouveau_exa.c nouveau_xv.c nouveau_dri2.c \
 			 nouveau_wfb.c \
