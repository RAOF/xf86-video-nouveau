--- a/src/drmmode_display.c
+++ b/src/drmmode_display.c
@@ -627,6 +627,9 @@
 	drmmode_output->mode_output =
 		drmModeGetConnector(drmmode->fd, drmmode_output->output_id);
 
+	if (!drmmode_output->mode_output)
+		return XF86OutputStatusDisconnected;
+
 	switch (drmmode_output->mode_output->connection) {
 	case DRM_MODE_CONNECTED:
 		status = XF86OutputStatusConnected;
@@ -663,6 +666,9 @@
 	drmModePropertyPtr props;
 	xf86MonPtr ddc_mon = NULL;
 
+	if (!koutput)
+		return NULL;
+
 	/* look for an EDID property */
 	for (i = 0; i < koutput->count_props; i++) {
 		props = drmModeGetProperty(drmmode->fd, koutput->props[i]);
@@ -927,6 +933,9 @@
 			drmModeGetConnector(drmmode->fd, drmmode_output->output_id);
 	}
 
+	if (!drmmode_output->mode_output)
+		return FALSE;
+
 	for (i = 0; i < drmmode_output->num_props; i++) {
 		drmmode_prop_ptr p = &drmmode_output->props[i];
 		if (p->atoms[0] != property)
@@ -1437,6 +1446,7 @@
 	if (drmmode->uevent_monitor) {
 		struct udev *u = udev_monitor_get_udev(drmmode->uevent_monitor);
 
+		RemoveGeneralSocket(udev_monitor_get_fd(drmmode->uevent_monitor));
 		udev_monitor_unref(drmmode->uevent_monitor);
 		udev_unref(u);
 	}
@@ -1524,6 +1534,12 @@
 drmmode_screen_fini(ScreenPtr pScreen)
 {
 	ScrnInfoPtr scrn = xf86ScreenToScrn(pScreen);
+	drmmode_ptr drmmode = drmmode_from_scrn(scrn);
 
 	drmmode_uevent_fini(scrn);
+
+	/* Register a wakeup handler to get informed on DRM events */
+	RemoveBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA,
+				     drmmode_wakeup_handler, scrn);
+	RemoveGeneralSocket(drmmode->fd);
 }
--- a/src/nv_driver.c
+++ b/src/nv_driver.c
@@ -432,8 +432,8 @@
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVLeaveVT is called.\n");
 
 	ret = drmDropMaster(pNv->dev->fd);
-	if (ret)
-		ErrorF("Error dropping master: %d\n", ret);
+	if (ret && errno != EIO && errno != ENODEV)
+		ErrorF("Error dropping master: %i(%m)\n", -errno);
 }
 
 static void
@@ -624,8 +624,9 @@
 {
 	NVPtr pNv = NVPTR(pScrn);
 
-	nouveau_device_del(&pNv->dev);
 	drmFree(pNv->drm_device_name);
+	nouveau_client_del(&pNv->client);
+	nouveau_device_del(&pNv->dev);
 }
 
 static Bool
