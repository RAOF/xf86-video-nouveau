commit 4515628ff78e07aea0d661ff3fd999c29cc55259
Author: Christopher James Halse Rogers <raof@ubuntu.com>
Date:   Mon Jul 22 17:46:58 2013 +1000

    Support running nested in a Mir compositor
    
    Signed-off-by: Christopher James Halse Rogers <raof@ubuntu.com>

Index: xf86-video-nouveau/src/nouveau_dri2.c
===================================================================
--- xf86-video-nouveau.orig/src/nouveau_dri2.c	2013-08-27 21:25:27.777887798 +1000
+++ xf86-video-nouveau/src/nouveau_dri2.c	2013-08-27 21:25:27.769887798 +1000
@@ -267,7 +267,7 @@
 	NVPtr pNv = NVPTR(scrn);
 	int i;
 
-	if (!xf86_config->num_crtc)
+	if (xorgMir || !xf86_config->num_crtc)
 		return FALSE;
 
 	for (i = 0; i < xf86_config->num_crtc; i++) {
@@ -290,7 +290,7 @@
 	ScrnInfoPtr scrn = xf86ScreenToScrn(draw->pScreen);
 	NVPtr pNv = NVPTR(scrn);
 
-	return pNv->glx_vblank &&
+	return pNv->glx_vblank && !xorgMir &&
 		nv_window_belongs_to_crtc(scrn, draw->x, draw->y,
 					  draw->width, draw->height);
 }
@@ -766,6 +766,19 @@
 	free(flip);
 }
 
+#if DRI2INFOREC_VERSION >= 8 && defined(XMIR)
+static int nouveau_dri2_auth_magic(ScreenPtr pScreen, uint32_t magic)
+{
+    ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+    NVPtr pNv = NVPTR(pScrn);
+
+    if (xorgMir)
+	return xmir_auth_drm_magic(pNv->xmir, magic);
+    else
+	return drmAuthMagic(pNv->dev->fd, magic);
+}
+#endif
+
 Bool
 nouveau_dri2_init(ScreenPtr pScreen)
 {
@@ -804,6 +817,11 @@
 	dri2.GetParam = NULL;
 #endif
 
+#if DRI2INFOREC_VERSION >= 8 && defined(XMIR)
+	dri2.version = 8;
+	dri2.AuthMagic2 = nouveau_dri2_auth_magic;
+#endif
+
 #if DRI2INFOREC_VERSION >= 9
 	dri2.version = 9;
 	dri2.CreateBuffer2 = nouveau_dri2_create_buffer2;
Index: xf86-video-nouveau/src/nv_driver.c
===================================================================
--- xf86-video-nouveau.orig/src/nv_driver.c	2013-08-27 21:25:27.777887798 +1000
+++ xf86-video-nouveau/src/nv_driver.c	2013-08-27 21:26:02.977889008 +1000
@@ -226,6 +226,8 @@
 	case GET_REQUIRED_HW_INTERFACES:
 	    flag = (CARD32 *)data;
 	    (*flag) = 0;
+	    if (xorgMir)
+		*flag |= HW_SKIP_CONSOLE;
 	    return TRUE;
 	default:
 	    return FALSE;
@@ -333,6 +335,23 @@
 }
 
 static Bool
+NVHasMirSupport(struct pci_device *pci_dev)
+{
+	char *busid;
+
+	busid = XNFprintf("pci:%04x:%02x:%02x.%d",
+			  pci_dev->domain, pci_dev->bus, pci_dev->dev, pci_dev->func);
+
+	if (xmir_get_drm_fd(busid) < 0) {
+		xf86DrvMsg(-1, X_ERROR, "[XMir] GPU %s not handled by Mir\n", busid);
+		free(busid);
+		return FALSE;
+	}
+	free(busid);
+	return TRUE;
+}
+
+static Bool
 NVPciProbe(DriverPtr drv, int entity_num, struct pci_device *pci_dev,
 	   intptr_t match_data)
 {
@@ -343,6 +362,9 @@
 	};
 	ScrnInfoPtr pScrn = NULL;
 
+	if (xorgMir && !NVHasMirSupport(pci_dev))
+		return FALSE;
+
 	if (!NVHasKMS(pci_dev))
 		return FALSE;
 
@@ -367,6 +389,9 @@
 	if (!dev->pdev)
 		return FALSE;
 
+	if (xorgMir && !NVHasMirSupport(dev->pdev))
+		return FALSE;
+
 	if (!NVHasKMS(dev->pdev))
 		return FALSE;
 
@@ -424,9 +449,11 @@
 
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVEnterVT is called.\n");
 
-	ret = drmSetMaster(pNv->dev->fd);
-	if (ret)
-		ErrorF("Unable to get master: %s\n", strerror(errno));
+	if (!xorgMir) {
+		ret = drmSetMaster(pNv->dev->fd);
+		if (ret)
+			ErrorF("Unable to get master: %s\n", strerror(errno));
+	}
 
 	if (XF86_CRTC_CONFIG_PTR(pScrn)->num_crtc && !xf86SetDesiredModes(pScrn))
 		return FALSE;
@@ -452,6 +479,9 @@
 
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "NVLeaveVT is called.\n");
 
+	if (xorgMir)
+		return;
+
 	ret = drmDropMaster(pNv->dev->fd);
 	if (ret && errno != EIO && errno != ENODEV)
 		ErrorF("Error dropping master: %i(%m)\n", -errno);
@@ -501,6 +531,50 @@
 }
 #endif
 
+#ifdef XMIR
+static void
+nouveau_xmir_copy_to_mir(xmir_window *xmir_win, RegionPtr region)
+{
+	WindowPtr win = xmir_window_to_windowptr(xmir_win);
+	PixmapPtr src = (*win->drawable.pScreen->GetWindowPixmap)(win);
+	ScreenPtr pScreen = src->drawable.pScreen;
+	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
+	NVPtr pNv = NVPTR(pScrn);
+	BoxPtr dst_box = xmir_window_get_drawable_region(xmir_win);
+	BoxPtr damage_box = RegionExtents(region);
+
+	int ret;
+	int w = damage_box->x2 - damage_box->x1;
+	int h = damage_box->y2 - damage_box->y1;
+	struct nouveau_bo *dst = NULL;
+
+	ret = nouveau_bo_prime_handle_ref(pNv->dev, xmir_window_get_fd(xmir_win), &dst);
+	assert(!ret);
+
+	NVAccelM2MF(pNv, w, h, src->drawable.bitsPerPixel >> 3, 0, 0,
+		    nouveau_pixmap_bo(src), NOUVEAU_BO_VRAM,
+		    exaGetPixmapPitch(src),
+		    src->drawable.height,
+		    damage_box->x1, damage_box->y1,
+		    dst, NOUVEAU_BO_VRAM,
+		    xmir_window_get_stride(xmir_win),
+		    dst_box->y2 - dst_box->y1,
+		    damage_box->x1 - dst_box->x1, damage_box->y1 - dst_box->y1);
+	if (pNv->NvCopy)
+		PUSH_KICK(pNv->ce_pushbuf);
+	else
+		PUSH_KICK(pNv->pushbuf);
+
+	xmir_submit_rendering_for_window(xmir_win, region);
+	nouveau_bo_ref(NULL, &dst);
+}
+
+static xmir_driver xmir_nouveau_driver = {
+    XMIR_DRIVER_VERSION,
+    nouveau_xmir_copy_to_mir
+};
+#endif
+
 static void 
 NVBlockHandler (BLOCKHANDLER_ARGS_DECL)
 {
@@ -516,6 +590,11 @@
 	nouveau_dirty_update(pScreen);
 #endif
 
+#ifdef XMIR
+	if (pNv->xmir)
+		xmir_screen_for_each_damaged_window(pNv->xmir, nouveau_xmir_copy_to_mir);
+#endif
+
 	if (pScrn->vtSema && !pNv->NoAccel)
 		nouveau_pushbuf_kick(pNv->pushbuf, pNv->pushbuf->channel);
 
@@ -535,7 +614,10 @@
 		return FALSE;
 	pScreen->CreateScreenResources = NVCreateScreenResources;
 
-	drmmode_fbcon_copy(pScreen);
+	if (!xorgMir)
+		drmmode_fbcon_copy(pScreen);
+	else if (!xf86SetDesiredModes(pScrn))
+		return FALSE;
 	if (!NVEnterVT(VT_FUNC_ARGS(0)))
 		return FALSE;
 
@@ -561,7 +643,7 @@
 	ScrnInfoPtr pScrn = xf86ScreenToScrn(pScreen);
 	NVPtr pNv = NVPTR(pScrn);
 
-	if (XF86_CRTC_CONFIG_PTR(pScrn)->num_crtc)
+	if (!xorgMir && XF86_CRTC_CONFIG_PTR(pScrn)->num_crtc)
 		drmmode_screen_fini(pScreen);
 
 	if (!pNv->NoAccel)
@@ -688,7 +770,7 @@
 	NVPtr pNv = NVPTR(pScrn);
 	NVEntPtr pNVEnt = NVEntPriv(pScrn);
 	struct pci_device *dev = pNv->PciInfo;
-	char *busid;
+	char *busid = NULL;
 	drmSetVersion sv;
 	int err;
 	int ret;
@@ -712,8 +794,11 @@
 	busid = XNFprintf("pci:%04x:%02x:%02x.%d",
 			  dev->domain, dev->bus, dev->dev, dev->func);
 #endif
+	if (!xorgMir)
+		ret = nouveau_device_open(busid, &pNv->dev);
+	else
+		ret = nouveau_device_wrap(xmir_get_drm_fd(busid), 0, &pNv->dev);
 
-	ret = nouveau_device_open(busid, &pNv->dev);
 	if (ret) {
 		xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 			   "[drm] Failed to open DRM device for %s: %d\n",
@@ -723,6 +808,9 @@
 	}
 	free(busid);
 
+	if (xorgMir)
+		return TRUE;
+
 	sv.drm_di_major = 1;
 	sv.drm_di_minor = 1;
 	sv.drm_dd_major = -1;
@@ -818,6 +906,14 @@
 		)
 		return FALSE;
 
+#ifdef XMIR
+	if (xorgMir) {
+		pNv->xmir = xmir_screen_create(pScrn);
+		if (pNv->xmir == NULL)
+			NVPreInitFail("Mir failed to initialize\n");
+	}
+#endif
+
 	if (xf86IsEntityShared(pScrn->entityList[0])) {
 		if(!xf86IsPrimInitDone(pScrn->entityList[0])) {
 			pNv->Primary = TRUE;
@@ -965,6 +1061,8 @@
 		from = X_CONFIG;
 		pNv->HWCursor = FALSE;
 	}
+	if (xorgMir)
+		pNv->HWCursor = FALSE;
 	xf86DrvMsg(pScrn->scrnIndex, from, "Using %s cursor\n",
 		pNv->HWCursor ? "HW" : "SW");
 
@@ -997,7 +1095,7 @@
 				      &pNv->glx_vblank))
 			from = X_CONFIG;
 		else
-			pNv->glx_vblank = TRUE;
+			pNv->glx_vblank = !xorgMir;
 
 		xf86DrvMsg(pScrn->scrnIndex, from, "GLX sync to VBlank %s.\n",
 			   pNv->glx_vblank ? "enabled" : "disabled");
@@ -1062,7 +1160,13 @@
 	xf86DrvMsg(pScrn->scrnIndex, from, "Swap limit set to %d [Max allowed %d]%s\n",
 		   pNv->swap_limit, pNv->max_swap_limit, reason);
 
-	ret = drmmode_pre_init(pScrn, pNv->dev->fd, pScrn->bitsPerPixel >> 3);
+#ifdef XMIR
+	if (xorgMir) {
+		xmir_screen_pre_init(pScrn, pNv->xmir, &xmir_nouveau_driver);
+		ret = TRUE;
+	} else
+#endif
+		ret = drmmode_pre_init(pScrn, pNv->dev->fd, pScrn->bitsPerPixel >> 3);
 	if (ret == FALSE)
 		NVPreInitFail("Kernel modesetting failed to initialize\n");
 
@@ -1170,7 +1274,8 @@
 {
 	NVPtr pNv = NVPTR(pScrn);
 
-	drmmode_remove_fb(pScrn);
+	if (!xorgMir)
+		drmmode_remove_fb(pScrn);
 
 	nouveau_bo_ref(NULL, &pNv->transfer);
 	nouveau_bo_ref(NULL, &pNv->scanout);
@@ -1384,6 +1489,11 @@
 	 */
 	miDCInitialize(pScreen, xf86GetPointerScreenFuncs());
 
+#ifdef XMIR
+	if (pNv->xmir)
+		xmir_screen_init(pScreen, pNv->xmir);
+#endif
+
 	/*
 	 * Initialize HW cursor layer. 
 	 * Must follow software cursor initialization.
@@ -1443,19 +1553,19 @@
 	 * Initialize colormap layer.
 	 * Must follow initialization of the default colormap 
 	 */
-	if (xf86_config->num_crtc &&
+	if (!xorgMir && xf86_config->num_crtc &&
 	    !xf86HandleColormaps(pScreen, 256, 8, NVLoadPalette,
 				 NULL, CMAP_PALETTED_TRUECOLOR))
-		return FALSE;
 
 	/* Report any unused options (only for the first generation) */
 	if (serverGeneration == 1)
 		xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
 
-	if (xf86_config->num_crtc)
+	if (!xorgMir && xf86_config->num_crtc)
 		drmmode_screen_init(pScreen);
 	else
 		pNv->glx_vblank = FALSE;
+
 	return TRUE;
 }
 
Index: xf86-video-nouveau/src/nv_type.h
===================================================================
--- xf86-video-nouveau.orig/src/nv_type.h	2013-08-27 21:25:27.777887798 +1000
+++ xf86-video-nouveau/src/nv_type.h	2013-08-27 21:25:27.769887798 +1000
@@ -9,6 +9,14 @@
 #include <stdint.h>
 #include "xf86Crtc.h"
 
+#ifdef XMIR
+#include "xmir.h"
+#include "xf86Priv.h"
+#else
+typedef struct xmir_screen xmir_screen;
+#define xorgMir 0
+#endif
+
 #if XF86_CRTC_VERSION >= 5
 #define NOUVEAU_PIXMAP_SHARING 1
 #endif
@@ -112,6 +120,8 @@
 	PixmapPtr pspix, pmpix, pdpix;
 	PicturePtr pspict, pmpict;
 	Pixel fg_colour;
+
+	xmir_screen *xmir;
 } NVRec;
 
 #define NVPTR(p) ((NVPtr)((p)->driverPrivate))
